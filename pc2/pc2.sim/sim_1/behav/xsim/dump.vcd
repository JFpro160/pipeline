$date
   Fri Nov 15 21:43:31 2024
$end

$version
  2024.1
  $dumpfile ("dump.vcd") 
$end

$timescale
  1ps
$end

$scope module testbench $end
$var reg 1 ! clk $end
$var reg 1 " reset $end
$var wire 32 # WriteData [31:0] $end
$var wire 32 $ DataAdr [31:0] $end
$var wire 1 % MemWrite $end
$scope module dut $end
$var wire 1 & clk $end
$var wire 1 ' reset $end
$var wire 32 # WriteData [31:0] $end
$var wire 32 $ DataAdr [31:0] $end
$var wire 1 % MemWrite $end
$var wire 32 ( PC [31:0] $end
$var wire 32 ) Instr [31:0] $end
$var wire 32 * ReadData [31:0] $end
$scope module arm $end
$var wire 1 & clk $end
$var wire 1 ' reset $end
$var wire 32 ( PC [31:0] $end
$var wire 32 ) Instr [31:0] $end
$var wire 1 % MemWrite $end
$var wire 32 $ ALUResult [31:0] $end
$var wire 32 # WriteData [31:0] $end
$var wire 32 * ReadData [31:0] $end
$var wire 4 + ALUFlags [3:0] $end
$var wire 1 , RegWrite $end
$var wire 1 - ALUSrc $end
$var wire 1 . MemtoReg $end
$var wire 1 / PCSrc $end
$var wire 2 0 RegSrc [1:0] $end
$var wire 2 1 ImmSrc [1:0] $end
$var wire 3 2 ALUControl [2:0] $end
$var wire 1 3 MulOp $end
$scope module c $end
$var wire 1 & clk $end
$var wire 1 ' reset $end
$var wire 20 4 Instr [31:12] $end
$var wire 4 + ALUFlags [3:0] $end
$var wire 2 0 RegSrc [1:0] $end
$var wire 1 , RegWrite $end
$var wire 2 1 ImmSrc [1:0] $end
$var wire 1 - ALUSrc $end
$var wire 3 2 ALUControl [2:0] $end
$var wire 1 % MemWrite $end
$var wire 1 . MemtoReg $end
$var wire 1 / PCSrc $end
$var wire 1 3 MulOp $end
$var wire 4 5 MulCode [7:4] $end
$var wire 2 6 FlagW [1:0] $end
$var wire 1 7 PCS $end
$var wire 1 8 RegW $end
$var wire 1 9 MemW $end
$scope module dec $end
$var wire 2 : Op [27:26] $end
$var wire 6 ; Funct [25:20] $end
$var wire 4 < Rd [15:12] $end
$var wire 4 5 MulCode [7:4] $end
$var reg 2 = FlagW [1:0] $end
$var wire 1 7 PCS $end
$var wire 1 8 RegW $end
$var wire 1 9 MemW $end
$var wire 1 . MemtoReg $end
$var wire 1 - ALUSrc $end
$var wire 2 1 ImmSrc [1:0] $end
$var wire 2 0 RegSrc [1:0] $end
$var reg 3 > ALUControl [2:0] $end
$var wire 1 3 MulOp $end
$var reg 10 ? controls [9:0] $end
$var wire 1 @ Branch $end
$var wire 1 A ALUOp $end
$upscope $end
$scope module cl $end
$var wire 1 & clk $end
$var wire 1 ' reset $end
$var wire 4 B Cond [31:28] $end
$var wire 4 + ALUFlags [3:0] $end
$var wire 2 6 FlagW [1:0] $end
$var wire 1 7 PCS $end
$var wire 1 8 RegW $end
$var wire 1 9 MemW $end
$var wire 1 / PCSrc $end
$var wire 1 , RegWrite $end
$var wire 1 % MemWrite $end
$var wire 2 C FlagWrite [1:0] $end
$var wire 4 D Flags [3:0] $end
$var wire 1 E CondEx $end
$scope module flagreg1 $end
$var wire 1 & clk $end
$var wire 1 ' reset $end
$var wire 1 F en $end
$var wire 2 G d [3:2] $end
$var reg 2 H q [1:0] $end
$upscope $end
$scope module flagreg0 $end
$var wire 1 & clk $end
$var wire 1 ' reset $end
$var wire 1 I en $end
$var wire 2 J d [1:0] $end
$var reg 2 K q [1:0] $end
$upscope $end
$scope module cc $end
$var wire 4 B Cond [31:28] $end
$var wire 4 D Flags [3:0] $end
$var reg 1 L CondEx $end
$var wire 1 M neg $end
$var wire 1 N zero $end
$var wire 1 O carry $end
$var wire 1 P overflow $end
$var wire 1 Q ge $end
$upscope $end
$upscope $end
$upscope $end
$scope module dp $end
$var wire 1 & clk $end
$var wire 1 ' reset $end
$var wire 2 0 RegSrc [1:0] $end
$var wire 1 , RegWrite $end
$var wire 2 1 ImmSrc [1:0] $end
$var wire 1 - ALUSrc $end
$var wire 3 2 ALUControl [2:0] $end
$var wire 1 . MemtoReg $end
$var wire 1 / PCSrc $end
$var wire 4 + ALUFlags [3:0] $end
$var wire 32 ( PC [31:0] $end
$var wire 32 ) Instr [31:0] $end
$var wire 32 $ ALUResult [31:0] $end
$var wire 32 # WriteData [31:0] $end
$var wire 32 * ReadData [31:0] $end
$var wire 32 R PCNext [31:0] $end
$var wire 32 S PCPlus4 [31:0] $end
$var wire 32 T PCPlus8 [31:0] $end
$var wire 32 U ExtImm [31:0] $end
$var wire 32 V SrcA [31:0] $end
$var wire 32 W SrcB [31:0] $end
$var wire 32 X SrcC [31:0] $end
$var wire 32 Y Result [31:0] $end
$var wire 4 Z RA1 [3:0] $end
$var wire 4 [ RA1Wire [3:0] $end
$var wire 4 \ RA2 [3:0] $end
$var wire 4 ] WA3 [3:0] $end
$var wire 1 3 MulOp $end
$scope module pcmux $end
$var wire 32 S d0 [31:0] $end
$var wire 32 Y d1 [31:0] $end
$var wire 1 / s $end
$var wire 32 R y [31:0] $end
$upscope $end
$scope module pcreg $end
$var wire 1 & clk $end
$var wire 1 ' reset $end
$var wire 32 R d [31:0] $end
$var reg 32 ^ q [31:0] $end
$upscope $end
$scope module pcadd1 $end
$var wire 32 ( a [31:0] $end
$var wire 32 _ b [31:0] $end
$var wire 32 S y [31:0] $end
$upscope $end
$scope module pcadd2 $end
$var wire 32 S a [31:0] $end
$var wire 32 _ b [31:0] $end
$var wire 32 T y [31:0] $end
$upscope $end
$scope module mulra1mux $end
$var wire 4 ` d0 [19:16] $end
$var wire 4 a d1 [11:8] $end
$var wire 1 3 s $end
$var wire 4 [ y [3:0] $end
$upscope $end
$scope module ra1mux $end
$var wire 4 [ d0 [3:0] $end
$var wire 4 b d1 [3:0] $end
$var wire 1 c s $end
$var wire 4 Z y [3:0] $end
$upscope $end
$scope module ra2mux $end
$var wire 4 d d0 [3:0] $end
$var wire 4 < d1 [15:12] $end
$var wire 1 e s $end
$var wire 4 \ y [3:0] $end
$upscope $end
$scope module rwa3mux $end
$var wire 4 < d0 [15:12] $end
$var wire 4 ` d1 [19:16] $end
$var wire 1 3 s $end
$var wire 4 ] y [3:0] $end
$upscope $end
$scope module rf $end
$var wire 1 & clk $end
$var wire 1 , we3 $end
$var wire 4 Z ra1 [3:0] $end
$var wire 4 \ ra2 [3:0] $end
$var wire 4 < ra3 [15:12] $end
$var wire 4 ] wa3 [3:0] $end
$var wire 32 Y wd3 [31:0] $end
$var wire 32 T r15 [31:0] $end
$var wire 32 V rd1 [31:0] $end
$var wire 32 # rd2 [31:0] $end
$var wire 32 X rd3 [31:0] $end
$upscope $end
$scope module resmux $end
$var wire 32 $ d0 [31:0] $end
$var wire 32 * d1 [31:0] $end
$var wire 1 . s $end
$var wire 32 Y y [31:0] $end
$upscope $end
$scope module ext $end
$var wire 24 f Instr [23:0] $end
$var wire 2 1 ImmSrc [1:0] $end
$var reg 32 g ExtImm [31:0] $end
$upscope $end
$scope module srcbmux $end
$var wire 32 # d0 [31:0] $end
$var wire 32 U d1 [31:0] $end
$var wire 1 - s $end
$var wire 32 W y [31:0] $end
$upscope $end
$scope module alu $end
$var wire 32 V a [31:0] $end
$var wire 32 W b [31:0] $end
$var wire 32 X c [31:0] $end
$var wire 3 2 ALUControl [2:0] $end
$var reg 32 h Result [31:0] $end
$var wire 4 + ALUFlags [3:0] $end
$var wire 1 i neg $end
$var wire 1 j zero $end
$var wire 1 k carry $end
$var wire 1 l overflow $end
$var wire 32 m condinvb [31:0] $end
$var wire 33 n sum [32:0] $end
$upscope $end
$upscope $end
$upscope $end
$scope module imem $end
$var wire 32 ( a [31:0] $end
$var wire 32 ) rd [31:0] $end
$upscope $end
$scope module dmem $end
$var wire 1 & clk $end
$var wire 1 % we $end
$var wire 32 $ a [31:0] $end
$var wire 32 # wd [31:0] $end
$var wire 32 * rd [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end

#0
$dumpvars
1!
1"
b1000 #
b0 $
0%
1&
1'
b0 (
b11100000010011110001000000001111 )
bx *
b110 +
1,
0-
0.
0/
b0 0
b0 1
b1 2
03
b11100000010011110001 4
b0 5
b0 6
07
18
09
b0 :
b100 ;
b1 <
b0 =
b1 >
b1001 ?
0@
1A
b1110 B
b0 C
b0 D
1E
0F
b1 G
b0 H
0I
b10 J
b0 K
1L
0M
0N
0O
0P
1Q
b100 R
b100 S
b1000 T
b1111 U
b1000 V
b1000 W
bx X
b0 Y
b1111 Z
b1111 [
b1111 \
b1 ]
b0 ^
b100 _
b1111 `
b0 a
b1111 b
0c
b1111 d
0e
b10011110001000000001111 f
b1111 g
b0 h
0i
1j
1k
0l
b11111111111111111111111111110111 m
b100000000000000000000000000000000 n
$end

#5000
0!
0&

#10000
1!
1&
b0 X

#15000
0!
0&

#20000
1!
1&

#22000
0"
0'

#25000
0!
0&

#30000
1!
b1100 #
1&
b100 (
b11100000010011110010000000001111 )
b11100000010011110010 4
b0 5
b0 :
b100 ;
b10 <
b1110 B
b1000 R
b1000 S
b1100 T
b1100 V
b1100 W
bx X
b10 ]
b100 ^
b1111 `
b0 a
b1111 d
b10011110010000000001111 f
b11111111111111111111111111110011 m
b100000000000000000000000000000000 n

#35000
0!
0&

#40000
1!
b10000 #
1&
b1000 (
b11100000010011110011000000001111 )
b11100000010011110011 4
b0 5
b0 :
b100 ;
b11 <
b1110 B
b1100 R
b1100 S
b10000 T
b10000 V
b10000 W
bx X
b11 ]
b1000 ^
b1111 `
b0 a
b1111 d
b10011110011000000001111 f
b11111111111111111111111111101111 m
b100000000000000000000000000000000 n

#45000
0!
0&

#50000
1!
b0 #
b11 $
1&
b1100 (
b11100010100000010001000000000011 )
b0 +
1-
b0 2
b11100010100000010001 4
b0 5
b0 :
b101000 ;
b1 <
b0 >
b101001 ?
b1110 B
b0 G
b0 J
b10000 R
b10000 S
b10100 T
b11 U
b0 V
b11 W
b0 X
b11 Y
b1 Z
b1 [
b11 \
b1 ]
b1100 ^
b1 `
b0 a
b11 d
b100000010001000000000011 f
b11 g
b11 h
0j
0k
b11 m
b11 n

#55000
0!
0&

#60000
1!
bx #
b101 $
1&
b10000 (
b11100010100000100010000000000101 )
b11100010100000100010 4
b0 5
b0 :
b101000 ;
b10 <
b1110 B
b10100 R
b10100 S
b11000 T
b101 U
b0 V
b101 W
b0 X
b101 Y
b10 Z
b10 [
b101 \
b10 ]
b10000 ^
b10 `
b0 a
b101 d
b100000100010000000000101 f
b101 g
b101 h
b101 m
b101 n

#65000
0!
0&

#70000
1!
b0 #
b11 $
1&
b10100 (
b11100010100000110011000000000011 )
b11100010100000110011 4
b0 5
b0 :
b101000 ;
b11 <
b1110 B
b11000 R
b11000 S
b11100 T
b11 U
b0 V
b11 W
b0 X
b11 Y
b11 Z
b11 [
b11 \
b11 ]
b10100 ^
b11 `
b0 a
b11 d
b100000110011000000000011 f
b11 g
b11 h
b11 m
b11 n

#75000
0!
0&

#80000
1!
b11 #
b1111 $
1&
b11000 (
b11100000000000000000001010010001 )
0-
b100 2
13
b11100000000000000000 4
b1001 5
b0 :
b0 ;
b0 <
b100 >
b1001 ?
b1110 B
b11100 R
b11100 S
b100000 T
b10010001 U
b101 V
b11 W
bx X
b1111 Y
b10 Z
b10 [
b1 \
b0 ]
b11000 ^
b0 `
b10 a
b1 d
b1010010001 f
b10010001 g
b1111 h
b11 m
b1000 n

#85000
0!
0&

#90000
1!
b10010 $
1&
b11100 (
b11100000001000000011001010010001 )
b10 +
b101 2
b11100000001000000011 4
b1001 5
b0 :
b10 ;
b11 <
b101 >
b1110 B
b0 G
b10 J
b100000 R
b100000 S
b100100 T
b11 X
b10010 Y
b11100 ^
b0 `
b10 a
b1 d
b1000000011001010010001 f
b10010 h
1k
b11111111111111111111111111111100 m
b100000000000000000000000000000010 n

#95000
0!
0&

#100000
1!
bx #
bx $
1&
b100000 (
bx )
bx +
x,
x/
bx 2
x3
bx 4
bx 5
bx 6
x7
bx :
bx ;
bx <
bx =
bx >
bx B
bx C
xE
xF
bx G
xI
bx J
xL
bx R
b100100 S
b101000 T
b0xxxxxxxx U
bx V
bx W
bx X
bx Y
bx Z
bx [
bx \
bx ]
b100000 ^
bx `
bx a
bx d
bx f
b0xxxxxxxx g
bx h
xi
xj
xk
xl
bx m
bx n

#105000
0!
0&

#110000
1!
1&
bx (
bx S
bx T
bx ^

#115000
0!
0&

#120000
1!
1&

#125000
0!
0&

#130000
1!
1&

#135000
0!
0&

#140000
1!
1&
